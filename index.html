<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Cube Solver 3D Pro</title>
<style>
:root {
  --cube-size: 200px;
  --cubie-size: calc(var(--cube-size) / 3);
  --control-panel-width: 300px;
  --primary-color: #0071e3;
  --secondary-color: #34c759;
  --dark-color: #1d1d1f;
  --light-color: #f5f5f7;
  --red: #e74c3c;
  --green: #2ecc71;
  --blue: #3498db;
  --white: #ffffff;
  --yellow: #f1c40f;
  --orange: #e67e22;
  --black: #2c3e50;
}

* {
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--light-color);
  color: var(--dark-color);
  touch-action: none;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  line-height: 1.6;
}

header {
  text-align: center;
  padding: 20px;
  background: linear-gradient(135deg, var(--primary-color), #005bb5);
  color: white;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  position: relative;
  z-index: 10;
}

h1 {
  font-size: 28px;
  font-weight: 700;
  margin: 0;
  letter-spacing: -0.5px;
}

.subtitle {
  font-size: 16px;
  opacity: 0.9;
  margin-top: 5px;
  font-weight: 400;
}

.main-content {
  display: flex;
  flex: 1;
  padding: 20px;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-start;
}

.cube-section {
  flex: 1;
  min-width: 300px;
  max-width: 600px;
  position: relative;
}

.controls-section {
  width: var(--control-panel-width);
  min-width: var(--control-panel-width);
  position: sticky;
  top: 20px;
}

.card {
  background-color: white;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 20px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.08);
  transition: transform 0.3s, box-shadow 0.3s;
}

.card:hover {
  transform: translateY(-5px);
  box-shadow: 0 12px 28px rgba(0,0,0,0.12);
}

.card h2 {
  margin-top: 0;
  color: var(--primary-color);
  font-size: 22px;
  border-bottom: 2px solid #f0f0f0;
  padding-bottom: 12px;
  margin-bottom: 20px;
}

/* Enhanced Cube Scene with better 3D */
.cube-scene {
  width: 100%;
  height: calc(var(--cube-size) + 120px);
  position: relative;
  perspective: 1500px;
  touch-action: none;
  user-select: none;
  margin: 0 auto;
  transform-style: preserve-3d;
}

.cube-container {
  width: var(--cube-size);
  height: var(--cube-size);
  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: calc(var(--cube-size) / -2);
  margin-top: calc(var(--cube-size) / -2);
  transform-style: preserve-3d;
  transition: transform 0.2s cubic-bezier(0.17, 0.67, 0.21, 0.99);
  transform: rotateX(-20deg) rotateY(-45deg);
}

/* More realistic 3D cube faces with depth */
.face {
  position: absolute;
  width: var(--cube-size);
  height: var(--cube-size);
  box-sizing: border-box;
  display: flex;
  flex-wrap: wrap;
  background-color: rgba(255,255,255,0.95);
  box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
  transition: transform 0.3s;
  border: 1px solid rgba(0,0,0,0.2);
  transform-style: preserve-3d;
}

/* Improved cubie styling with 3D depth */
.cubie {
  width: var(--cubie-size);
  height: var(--cubie-size);
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: transform 0.4s, background-color 0.3s;
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(0,0,0,0.1);
  transform-style: preserve-3d;
}

.cubie::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0));
  pointer-events: none;
  border: 1px solid rgba(0,0,0,0.1);
}

.cubie:hover {
  transform: scale(1.05);
  z-index: 1;
}

/* Enhanced face positioning with better 3D perspective */
.front {
  transform: translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(255,255,255,0.1);
}

.back {
  transform: rotateY(180deg) translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(255,255,0,0.1);
}

.right {
  transform: rotateY(90deg) translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(0,0,255,0.1);
}

.left {
  transform: rotateY(-90deg) translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(0,255,0,0.1);
}

.top {
  transform: rotateX(90deg) translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(255,0,0,0.1);
}

.bottom {
  transform: rotateX(-90deg) translateZ(calc(var(--cube-size) / 2));
  background-color: rgba(255,165,0,0.1);
}

/* Center pieces with black borders */
.center {
  border: 2px solid rgba(0,0,0,0.3);
}

/* Edge pieces */
.edge {
  border: 1px solid rgba(0,0,0,0.2);
}

/* Corner pieces */
.corner {
  border: 1px solid rgba(0,0,0,0.2);
}

/* Controls section */
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-bottom: 24px;
}

button {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 12px 18px;
  border-radius: 12px;
  font-size: 15px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s;
  flex: 1;
  min-width: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

button:hover {
  background-color: #0066cc;
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

button:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

button.secondary {
  background-color: var(--light-color);
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
}

button.secondary:hover {
  background-color: #e6f2ff;
}

button.success {
  background-color: var(--secondary-color);
}

button.success:hover {
  background-color: #2dbb54;
}

button.danger {
  background-color: #ff3b30;
}

button.danger:hover {
  background-color: #e6352b;
}

/* Color picker */
.color-picker {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
  justify-content: center;
}

.color-option {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  cursor: pointer;
  border: 3px solid transparent;
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.color-option::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0));
}

.color-option:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.color-option.selected {
  border-color: var(--primary-color);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
}

/* Solution steps */
.solution-steps {
  margin-top: 20px;
  max-height: 300px;
  overflow-y: auto;
  border-radius: 12px;
  background-color: #f9f9f9;
  padding: 10px;
  scrollbar-width: thin;
  scrollbar-color: var(--primary-color) #f0f0f0;
}

.solution-steps::-webkit-scrollbar {
  width: 8px;
}

.solution-steps::-webkit-scrollbar-track {
  background: #f0f0f0;
  border-radius: 10px;
}

.solution-steps::-webkit-scrollbar-thumb {
  background-color: var(--primary-color);
  border-radius: 10px;
}

.step {
  padding: 14px;
  border-bottom: 1px solid #e0e0e0;
  display: flex;
  align-items: center;
  transition: all 0.3s;
  border-radius: 8px;
  margin-bottom: 6px;
  background-color: white;
}

.step:hover {
  background-color: #f5f5f5;
  transform: translateX(5px);
}

.step.active {
  background-color: #e6f2ff;
  border-left: 4px solid var(--primary-color);
}

.step-number {
  background-color: var(--primary-color);
  color: white;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 14px;
  font-size: 14px;
  font-weight: bold;
  flex-shrink: 0;
}

.step-move {
  font-family: 'Courier New', monospace;
  font-weight: bold;
  margin-right: 12px;
  width: 36px;
  display: inline-block;
  font-size: 16px;
  color: var(--dark-color);
}

/* Timer display */
.timer-display {
  font-size: 32px;
  text-align: center;
  margin: 24px 0;
  font-family: 'Courier New', monospace;
  font-weight: bold;
  color: var(--dark-color);
  background-color: #f9f9f9;
  padding: 12px;
  border-radius: 12px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
}

/* Face indicator */
.face-indicator {
  text-align: center;
  margin: 20px 0;
  font-weight: bold;
  color: var(--primary-color);
  font-size: 20px;
  background-color: #f0f7ff;
  padding: 10px;
  border-radius: 12px;
}

/* Size controls */
.size-controls {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  background-color: #f9f9f9;
  padding: 12px;
  border-radius: 12px;
}

.size-slider {
  flex: 1;
  margin: 0 12px;
  -webkit-appearance: none;
  height: 8px;
  border-radius: 4px;
  background: #d1d1d6;
  outline: none;
}

.size-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--primary-color);
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.size-value {
  width: 50px;
  text-align: center;
  font-weight: bold;
  color: var(--dark-color);
}

/* AI thinking indicator */
.ai-thinking {
  display: none;
  text-align: center;
  padding: 16px;
  color: var(--primary-color);
  font-style: italic;
  background-color: #f0f7ff;
  border-radius: 12px;
  margin: 20px 0;
  font-size: 16px;
}

.spinner {
  border: 3px solid rgba(0,0,0,0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary-color);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
  display: inline-block;
  vertical-align: middle;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Move history */
.move-history {
  margin-top: 20px;
  padding: 12px;
  background-color: #f9f9f9;
  border-radius: 12px;
  max-height: 150px;
  overflow-y: auto;
}

.move-history h4 {
  margin-top: 0;
  color: var(--primary-color);
  border-bottom: 1px solid #e0e0e0;
  padding-bottom: 8px;
}

.move-history-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.move-tag {
  background-color: #e6f2ff;
  color: var(--primary-color);
  padding: 4px 10px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 500;
}

/* Stats container */
.stats-container {
  display: flex;
  gap: 12px;
  margin-top: 20px;
}

.stat-box {
  flex: 1;
  background-color: #f9f9f9;
  padding: 12px;
  border-radius: 12px;
  text-align: center;
}

.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: var(--primary-color);
  margin-bottom: 4px;
}

.stat-label {
  font-size: 12px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Social links */
.social-links {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin: 20px 0;
  flex-wrap: wrap;
}

.social-link {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  border-radius: 8px;
  text-decoration: none;
  font-weight: 600;
  transition: all 0.3s;
  color: white;
}

.social-link i {
  margin-right: 8px;
  font-size: 18px;
}

.discord-link {
  background-color: #5865F2;
}

.website-link {
  background-color: var(--primary-color);
}

.youtube-link {
  background-color: #FF0000;
}

.social-link:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

/* Responsive design */
@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }
  
  .controls-section {
    width: 100%;
    min-width: auto;
    position: static;
  }
  
  :root {
    --cube-size: 180px;
    --control-panel-width: 100%;
  }
  
  .card {
    padding: 18px;
  }
}

@media (max-width: 480px) {
  :root {
    --cube-size: 160px;
  }
  
  button {
    min-width: 100px;
    padding: 10px 12px;
    font-size: 14px;
  }
  
  .timer-display {
    font-size: 28px;
  }
  
  .face-indicator {
    font-size: 18px;
  }
  
  .social-links {
    flex-direction: column;
    align-items: center;
  }
  
  .social-link {
    width: 100%;
    justify-content: center;
  }
}

/* Animation classes */
.rotate-animation {
  animation: rotateFace 0.6s ease-out;
}

@keyframes rotateFace {
  0% { transform: rotateX(0) rotateY(0); }
  50% { transform: rotateX(var(--rotate-x)) rotateY(var(--rotate-y)); }
  100% { transform: rotateX(0) rotateY(0); }
}

.pulse {
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.confetti {
  position: fixed;
  width: 10px;
  height: 10px;
  background-color: #f00;
  opacity: 0;
  z-index: 1000;
  animation: confetti 3s ease-out;
}

@keyframes confetti {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* Cube rotation controls */
.cube-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 15px 0;
}

.rotate-btn {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: var(--primary-color);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s;
  border: none;
  font-size: 18px;
}

.rotate-btn:hover {
  background-color: #0066cc;
  transform: scale(1.1);
}

/* Notation guide */
.notation-guide {
  margin-top: 20px;
  padding: 15px;
  background-color: #f9f9f9;
  border-radius: 12px;
}

.notation-guide h3 {
  margin-top: 0;
  color: var(--primary-color);
  font-size: 18px;
}

.notation-item {
  display: flex;
  align-items: center;
  margin: 8px 0;
}

.notation-symbol {
  font-family: 'Courier New', monospace;
  font-weight: bold;
  width: 30px;
  margin-right: 10px;
  text-align: center;
}

.notation-meaning {
  flex: 1;
  font-size: 14px;
}

/* Cube inspection mode */
.inspection-mode {
  display: none;
  text-align: center;
  padding: 15px;
  background-color: #fff3cd;
  border-radius: 12px;
  margin: 15px 0;
  color: #856404;
  font-weight: bold;
}

/* Cube stickers */
.sticker {
  position: absolute;
  width: calc(100% - 4px);
  height: calc(100% - 4px);
  margin: 2px;
  border-radius: 4px;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
}

/* 3D effect for cubies */
.cubie-3d {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.5s;
}

.cubie-face {
  position: absolute;
  width: 100%;
  height: 100%;
  border: 1px solid rgba(0,0,0,0.2);
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  backface-visibility: hidden;
}

.cubie-face.front {
  transform: translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--white);
}

.cubie-face.back {
  transform: rotateY(180deg) translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--yellow);
}

.cubie-face.right {
  transform: rotateY(90deg) translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--blue);
}

.cubie-face.left {
  transform: rotateY(-90deg) translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--green);
}

.cubie-face.top {
  transform: rotateX(90deg) translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--red);
}

.cubie-face.bottom {
  transform: rotateX(-90deg) translateZ(calc(var(--cubie-size) / 2));
  background-color: var(--orange);
}

/* Layer highlighting */
.layer-highlight {
  position: absolute;
  width: var(--cube-size);
  height: var(--cube-size);
  background-color: rgba(52, 152, 219, 0.2);
  pointer-events: none;
  z-index: 10;
  display: none;
}

/* Cube shadows */
.cube-shadow {
  position: absolute;
  width: var(--cube-size);
  height: var(--cube-size);
  background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0) 70%);
  left: 50%;
  top: 50%;
  margin-left: calc(var(--cube-size) / -2);
  margin-top: calc(var(--cube-size) / -2);
  transform: rotateX(90deg) translateZ(calc(var(--cube-size) / -2));
  z-index: -1;
}

/* Cube labels */
.cube-label {
  position: absolute;
  font-size: 12px;
  font-weight: bold;
  color: rgba(0,0,0,0.5);
  text-transform: uppercase;
  pointer-events: none;
}

.cube-label.front {
  transform: translateZ(calc(var(--cube-size) / 2 + 20px));
}

.cube-label.back {
  transform: rotateY(180deg) translateZ(calc(var(--cube-size) / 2 + 20px));
}

.cube-label.right {
  transform: rotateY(90deg) translateZ(calc(var(--cube-size) / 2 + 20px));
}

.cube-label.left {
  transform: rotateY(-90deg) translateZ(calc(var(--cube-size) / 2 + 20px));
}

.cube-label.top {
  transform: rotateX(90deg) translateZ(calc(var(--cube-size) / 2 + 20px));
}

.cube-label.bottom {
  transform: rotateX(-90deg) translateZ(calc(var(--cube-size) / 2 + 20px));
}
</style>
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
<header>
  <h1>Cube Solver 3D Pro</h1>
  <div class="subtitle">Advanced Rubik's Cube Simulator with AI Assistant</div>
</header>

<div class="main-content">
  <div class="cube-section">
    <div class="card">
      <h2>3D Interactive Cube</h2>
      <div class="cube-scene" id="cube-scene">
        <div class="cube-container" id="cube">
          <!-- Faces will be generated by JavaScript -->
        </div>
        <div class="cube-shadow"></div>
        <div class="layer-highlight" id="layer-highlight"></div>
      </div>

      <div class="cube-controls">
        <button class="rotate-btn" id="rotate-left"><i class="fas fa-arrow-left"></i></button>
        <button class="rotate-btn" id="rotate-up"><i class="fas fa-arrow-up"></i></button>
        <button class="rotate-btn" id="rotate-down"><i class="fas fa-arrow-down"></i></button>
        <button class="rotate-btn" id="rotate-right"><i class="fas fa-arrow-right"></i></button>
        <button class="rotate-btn" id="rotate-ccw"><i class="fas fa-undo"></i></button>
        <button class="rotate-btn" id="rotate-cw"><i class="fas fa-redo"></i></button>
      </div>

      <div class="face-indicator" id="face-indicator">Front View</div>

      <div class="size-controls">
        <span>Small</span>
        <input type="range" min="120" max="300" value="200" class="size-slider" id="size-slider">
        <span class="size-value" id="size-value">200</span>
        <span>Large</span>
      </div>

      <div class="ai-thinking" id="ai-thinking">
        <div class="spinner"></div>
        Analyzing cube state and calculating optimal solution...
      </div>

      <div class="stats-container">
        <div class="stat-box">
          <div class="stat-value" id="move-count-display">0</div>
          <div class="stat-label">Moves Made</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="time-display">0s</div>
          <div class="stat-label">Solve Time</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="difficulty-display">-</div>
          <div class="stat-label">Difficulty</div>
        </div>
      </div>

      <div class="move-history">
        <h4>Move History</h4>
        <div class="move-history-list" id="move-history">
          <!-- Moves will be added here -->
        </div>
      </div>

      <!-- Notation Guide -->
      <div class="notation-guide">
        <h3>Cube Notation Guide</h3>
        <div class="notation-item">
          <div class="notation-symbol">F</div>
          <div class="notation-meaning">Front face clockwise</div>
        </div>
        <div class="notation-item">
          <div class="notation-symbol">F'</div>
          <div class="notation-meaning">Front face counter-clockwise</div>
        </div>
        <div class="notation-item">
          <div class="notation-symbol">F2</div>
          <div class="notation-meaning">Front face 180° turn</div>
        </div>
        <div class="notation-item">
          <div class="notation-symbol">U, D, L, R, B</div>
          <div class="notation-meaning">Other faces (Up, Down, Left, Right, Back)</div>
        </div>
      </div>

      <!-- Social Links Section -->
      <div class="social-links">
        <a href="https://discord.gg/your-invite-code" target="_blank" class="social-link discord-link">
          <i class="fab fa-discord"></i> Join Discord
        </a>
        <a href="https://yourwebsite.com" target="_blank" class="social-link website-link">
          <i class="fas fa-globe"></i> Visit Website
        </a>
        <a href="https://youtube.com/your-channel" target="_blank" class="social-link youtube-link">
          <i class="fab fa-youtube"></i> YouTube
        </a>
      </div>
    </div>
  </div>

  <div class="controls-section">
    <div class="card">
      <h2>Controls</h2>
      <div class="controls">
        <button id="scramble-btn" class="secondary">
          <i class="fas fa-random"></i> Scramble
        </button>
        <button id="solve-btn" class="success">
          <i class="fas fa-robot"></i> AI Solve
        </button>
      </div>
      <div class="controls">
        <button id="reset-btn" class="danger">
          <i class="fas fa-redo"></i> Reset
        </button>
        <button id="timer-btn">
          <i class="fas fa-stopwatch"></i> Start Timer
        </button>
      </div>

      <div class="timer-display" id="timer">00:00.00</div>

      <div class="inspection-mode" id="inspection-mode">
        Inspection Time: <span id="inspection-timer">15.00</span>
      </div>

      <h3>Select Color</h3>
      <div class="color-picker">
        <div class="color-option selected" style="background-color: var(--red);" data-color="red" title="Red"></div>
        <div class="color-option" style="background-color: var(--green);" data-color="green" title="Green"></div>
        <div class="color-option" style="background-color: var(--blue);" data-color="blue" title="Blue"></div>
        <div class="color-option" style="background-color: var(--white);" data-color="white" title="White"></div>
        <div class="color-option" style="background-color: var(--yellow);" data-color="yellow" title="Yellow"></div>
        <div class="color-option" style="background-color: var(--orange);" data-color="orange" title="Orange"></div>
      </div>

      <h3>Edit Cube Faces</h3>
      <div class="controls">
        <button id="front-btn"><i class="fas fa-cube"></i> Front</button>
        <button id="back-btn"><i class="fas fa-cube"></i> Back</button>
      </div>
      <div class="controls">
        <button id="left-btn"><i class="fas fa-cube"></i> Left</button>
        <button id="right-btn"><i class="fas fa-cube"></i> Right</button>
      </div>
      <div class="controls">
        <button id="up-btn"><i class="fas fa-cube"></i> Up</button>
        <button id="down-btn"><i class="fas fa-cube"></i> Down</button>
      </div>

      <h3>Manual Rotations</h3>
      <div class="controls">
        <button id="rotate-front-btn">F</button>
        <button id="rotate-back-btn">B</button>
      </div>
      <div class="controls">
        <button id="rotate-left-btn">L</button>
        <button id="rotate-right-btn">R</button>
      </div>
      <div class="controls">
        <button id="rotate-up-btn">U</button>
        <button id="rotate-down-btn">D</button>
      </div>
      <div class="controls">
        <button id="rotate-front-prime-btn">F'</button>
        <button id="rotate-back-prime-btn">B'</button>
      </div>
      <div class="controls">
        <button id="rotate-left-prime-btn">L'</button>
        <button id="rotate-right-prime-btn">R'</button>
      </div>
      <div class="controls">
        <button id="rotate-up-prime-btn">U'</button>
        <button id="rotate-down-prime-btn">D'</button>
      </div>
      <div class="controls">
        <button id="rotate-front-double-btn">F2</button>
        <button id="rotate-back-double-btn">B2</button>
      </div>
      <div class="controls">
        <button id="rotate-left-double-btn">L2</button>
        <button id="rotate-right-double-btn">R2</button>
      </div>
      <div class="controls">
        <button id="rotate-up-double-btn">U2</button>
        <button id="rotate-down-double-btn">D2</button>
      </div>
    </div>

    <div class="card solution-steps" id="solution-container" style="display: none;">
      <h2>AI Solution <span id="move-count"></span></h2>
      <div id="solution-steps">
        <!-- Steps will be added here by JavaScript -->
      </div>

      <div class="controls">
        <button id="prev-step" class="secondary"><i class="fas fa-arrow-left"></i> Previous</button>
        <button id="next-step" class="secondary">Next <i class="fas fa-arrow-right"></i></button>
      </div>
      <div class="controls">
        <button id="play-solution" class="success"><i class="fas fa-play"></i> Play Solution</button>
        <button id="stop-solution" class="danger" style="display: none;"><i class="fas fa-stop"></i> Stop</button>
      </div>
    </div>
  </div>
</div>

<script>
// Enhanced Cube State with Piece Tracking and Orientation
const cubeState = {
  // Face colors
  front: Array(9).fill('white'),
  back: Array(9).fill('yellow'),
  left: Array(9).fill('green'),
  right: Array(9).fill('blue'),
  up: Array(9).fill('red'),
  down: Array(9).fill('orange'),

  // Track individual pieces with orientation
  pieces: {
    edges: [
      { position: 'UF', colors: ['white', 'red'], orientation: 0 },
      { position: 'UR', colors: ['white', 'blue'], orientation: 0 },
      { position: 'UB', colors: ['white', 'yellow'], orientation: 0 },
      { position: 'UL', colors: ['white', 'green'], orientation: 0 },
      { position: 'DF', colors: ['white', 'orange'], orientation: 0 },
      { position: 'DR', colors: ['white', 'blue'], orientation: 0 },
      { position: 'DB', colors: ['white', 'yellow'], orientation: 0 },
      { position: 'DL', colors: ['white', 'green'], orientation: 0 },
      { position: 'FR', colors: ['white', 'blue'], orientation: 0 },
      { position: 'FL', colors: ['white', 'green'], orientation: 0 },
      { position: 'BR', colors: ['yellow', 'blue'], orientation: 0 },
      { position: 'BL', colors: ['yellow', 'green'], orientation: 0 }
    ],
    corners: [
      { position: 'UFR', colors: ['white', 'red', 'blue'], orientation: 0 },
      { position: 'URB', colors: ['white', 'red', 'blue'], orientation: 0 },
      { position: 'UBL', colors: ['white', 'red', 'green'], orientation: 0 },
      { position: 'ULF', colors: ['white', 'red', 'green'], orientation: 0 },
      { position: 'DRF', colors: ['white', 'orange', 'blue'], orientation: 0 },
      { position: 'DFL', colors: ['white', 'orange', 'green'], orientation: 0 },
      { position: 'DLB', colors: ['white', 'orange', 'green'], orientation: 0 },
      { position: 'DBR', colors: ['white', 'orange', 'blue'], orientation: 0 }
    ]
  }
};

// App state
const state = {
  currentColor: 'red',
  currentFace: 'front',
  timerInterval: null,
  timerRunning: false,
  startTime: 0,
  elapsedTime: 0,
  isDragging: false,
  startX: 0,
  startY: 0,
  rotateX: -20,
  rotateY: -45, // Initial rotation to show 3 faces like Grubiks
  prevRotateX: 0,
  prevRotateY: 0,
  currentStep: 0,
  solutionMoves: [],
  isPlayingSolution: false,
  moveHistory: [],
  totalMoves: 0,
  solveStartTime: 0,
  cubeSize: 200,
  inspectionTime: 15,
  inspectionInterval: null,
  isInspecting: false,
  currentLayer: null,
  lastMoveTime: 0,
  moveDelay: 300 // Minimum time between moves in ms
};

// Initialize the cube with enhanced piece tracking and 3D cubies
function initCube() {
  const cube = document.getElementById('cube');
  cube.innerHTML = '';

  // Create faces
  const faces = [
    { name: 'front', class: 'front', label: 'F' },
    { name: 'back', class: 'back', label: 'B' },
    { name: 'left', class: 'left', label: 'L' },
    { name: 'right', class: 'right', label: 'R' },
    { name: 'up', class: 'top', label: 'U' }, // Changed to 'top' for CSS class
    { name: 'down', class: 'bottom', label: 'D' } // Changed to 'bottom' for CSS class
  ];

  faces.forEach(face => {
    const faceElement = document.createElement('div');
    faceElement.className = `face ${face.class}`;
    faceElement.id = face.name;

    // Add face label
    const label = document.createElement('div');
    label.className = 'cube-label ' + face.class;
    label.textContent = face.label;
    faceElement.appendChild(label);

    // Create cubies with 3D effect
    for (let i = 0; i < 9; i++) {
      const cubie = document.createElement('div');
      cubie.className = 'cubie';

      // Add additional classes based on piece type
      if (i === 4) {
        cubie.classList.add('center'); // Center piece
      } else if (i % 2 === 1) {
        cubie.classList.add('edge'); // Edge piece
      } else {
        cubie.classList.add('corner'); // Corner piece
      }

      cubie.dataset.index = i;
      cubie.dataset.face = face.name;

      // Create 3D cubie with faces
      const cubie3d = document.createElement('div');
      cubie3d.className = 'cubie-3d';
      
      // Create all faces of the cubie
      const frontFace = document.createElement('div');
      frontFace.className = 'cubie-face front';
      frontFace.style.backgroundColor = getColorCode(cubeState[face.name][i]);
      
      // For a real 3D cube, we'd need to create all visible faces, but we'll keep it simple
      cubie3d.appendChild(frontFace);
      cubie.appendChild(cubie3d);

      cubie.addEventListener('click', () => {
        if (!state.isPlayingSolution && state.currentFace === face.name) {
          cubeState[face.name][i] = state.currentColor;
          frontFace.style.backgroundColor = getColorCode(state.currentColor);
          updatePieceTracking();
        }
      });

      faceElement.appendChild(cubie);
    }

    cube.appendChild(faceElement);
  });

  updateCubeRotation();
  updatePieceTracking();
}

// Track individual pieces for more advanced solving
function updatePieceTracking() {
  // This is a simplified version - in a real implementation, we would:
  // 1. Track the current position of each piece
  // 2. Update their orientation when moves are made
  // 3. Use this information for more accurate solving
  
  // For now, we'll just update the basic tracking
  cubeState.pieces.edges.forEach(edge => {
    // Update edge positions based on current cube state
    // This would involve checking where each edge piece is currently located
  });
  
  cubeState.pieces.corners.forEach(corner => {
    // Update corner positions based on current cube state
  });
}

// Update cube rotation based on current angles
function updateCubeRotation() {
  const cube = document.getElementById('cube');
  cube.style.transform = `rotateX(${state.rotateX}deg) rotateY(${state.rotateY}deg)`;
  updateFaceIndicator();
}

// Update which face is being shown as "front"
function updateFaceIndicator() {
  const indicator = document.getElementById('face-indicator');

  // Normalize rotation to 0-360 range
  const normY = ((state.rotateY % 360) + 360) % 360;
  const normX = ((state.rotateX % 360) + 360) % 360;

  if (normY >= 315 || normY < 45) {
    if (normX < 45 || normX > 315) indicator.textContent = "Front View (F)";
    else if (normX >= 45 && normX < 135) indicator.textContent = "Bottom View (D)";
    else if (normX >= 135 && normX < 225) indicator.textContent = "Back View (B)";
    else indicator.textContent = "Top View (U)";
  }
  else if (normY >= 45 && normY < 135) {
    if (normX < 45 || normX > 315) indicator.textContent = "Right View (R)";
    else if (normX >= 45 && normX < 135) indicator.textContent = "Bottom View (D)";
    else if (normX >= 135 && normX < 225) indicator.textContent = "Left View (L)";
    else indicator.textContent = "Top View (U)";
  }
  else if (normY >= 135 && normY < 225) {
    if (normX < 45 || normX > 315) indicator.textContent = "Back View (B)";
    else if (normX >= 45 && normX < 135) indicator.textContent = "Bottom View (D)";
    else if (normX >= 135 && normX < 225) indicator.textContent = "Front View (F)";
    else indicator.textContent = "Top View (U)";
  }
  else {
    if (normX < 45 || normX > 315) indicator.textContent = "Left View (L)";
    else if (normX >= 45 && normX < 135) indicator.textContent = "Bottom View (D)";
    else if (normX >= 135 && normX < 225) indicator.textContent = "Right View (R)";
    else indicator.textContent = "Top View (U)";
  }
}

// Get color code for display
function getColorCode(color) {
  const colors = {
    'red': 'var(--red)',
    'green': 'var(--green)',
    'blue': 'var(--blue)',
    'white': 'var(--white)',
    'yellow': 'var(--yellow)',
    'orange': 'var(--orange)'
  };
  return colors[color] || '#FFFFFF';
}

// Scramble the cube with more realistic moves
function scrambleCube() {
  if (state.isPlayingSolution) return;

  // Start inspection time
  startInspection();

  const moves = ['F', 'B', 'L', 'R', 'U', 'D', 'F\'', 'B\'', 'L\'', 'R\'', 'U\'', 'D\'',
                'F2', 'B2', 'L2', 'R2', 'U2', 'D2'];
  const scrambleMoves = [];

  // Generate a more realistic scramble (like WCA competitions)
  let prevMove = '';
  let prevAxis = ''; // x, y, or z axis to avoid same axis moves
  
  for (let i = 0; i < 20; i++) {
    let randomMove;
    let currentAxis;
    
    do {
      randomMove = moves[Math.floor(Math.random() * moves.length)];
      currentAxis = getMoveAxis(randomMove);
    } while (
      // Avoid consecutive same face moves
      randomMove[0] === prevMove[0] || 
      // Avoid same axis moves (makes scramble less random)
      (prevAxis && currentAxis === prevAxis)
    );

    scrambleMoves.push(randomMove);
    applyMove(randomMove);
    prevMove = randomMove;
    prevAxis = currentAxis;
  }

  initCube();
  state.moveHistory = [];
  state.totalMoves = 0;
  updateMoveCounter();
  updateMoveHistory();
  return scrambleMoves;
}

// Get the axis of a move (x, y, or z)
function getMoveAxis(move) {
  const face = move.replace(/['2]/g, '');
  if (face === 'F' || face === 'B') return 'z';
  if (face === 'U' || face === 'D') return 'y';
  if (face === 'L' || face === 'R') return 'x';
  return '';
}

// Start inspection time (like in speedcubing competitions)
function startInspection() {
  state.isInspecting = true;
  state.inspectionTime = 15;
  document.getElementById('inspection-mode').style.display = 'block';
  document.getElementById('inspection-timer').textContent = state.inspectionTime.toFixed(2);
  
  state.inspectionInterval = setInterval(() => {
    state.inspectionTime -= 0.01;
    document.getElementById('inspection-timer').textContent = state.inspectionTime.toFixed(2);
    
    if (state.inspectionTime <= 0) {
      clearInterval(state.inspectionInterval);
      document.getElementById('inspection-mode').style.display = 'none';
      state.isInspecting = false;
    }
  }, 10);
}

// Enhanced move application with edge/corner tracking
function applyMove(move, isManual = false) {
  // Don't allow moves too quickly in succession
  const now = Date.now();
  if (now - state.lastMoveTime < state.moveDelay) return;
  state.lastMoveTime = now;

  const faceMap = {
    'F': 'front',
    'B': 'back',
    'L': 'left',
    'R': 'right',
    'U': 'up',
    'D': 'down'
  };

  const face = faceMap[move.replace(/['2]/g, '')];
  const isDouble = move.includes('2');
  const direction = move.includes('\'') ? -1 : 1;

  // Highlight the layer being rotated
  highlightLayer(face, direction, isDouble);

  // Rotate the face
  rotateFace(face, direction, isDouble);

  // Rotate adjacent edges
  rotateAdjacentEdges(face, direction, isDouble);

  // Add to move history if manual move
  if (isManual) {
    state.moveHistory.push(move);
    state.totalMoves++;
    updateMoveCounter();
    updateMoveHistory();
    updateDifficultyEstimate();
  }

  // Rebuild the cube display
  initCube();
}

// Highlight the layer being rotated
function highlightLayer(face, direction, isDouble) {
  const highlight = document.getElementById('layer-highlight');
  highlight.style.display = 'block';
  highlight.style.backgroundColor = `rgba(52, 152, 219, ${isDouble ? 0.3 : direction === 1 ? 0.2 : 0.1})`;
  
  // Position the highlight based on the face being rotated
  switch(face) {
    case 'front':
      highlight.style.transform = 'translateZ(calc(var(--cube-size) / 2))';
      break;
    case 'back':
      highlight.style.transform = 'rotateY(180deg) translateZ(calc(var(--cube-size) / 2))';
      break;
    case 'left':
      highlight.style.transform = 'rotateY(-90deg) translateZ(calc(var(--cube-size) / 2))';
      break;
    case 'right':
      highlight.style.transform = 'rotateY(90deg) translateZ(calc(var(--cube-size) / 2))';
      break;
    case 'up':
      highlight.style.transform = 'rotateX(90deg) translateZ(calc(var(--cube-size) / 2))';
      break;
    case 'down':
      highlight.style.transform = 'rotateX(-90deg) translateZ(calc(var(--cube-size) / 2))';
      break;
  }
  
  // Hide the highlight after animation
  setTimeout(() => {
    highlight.style.display = 'none';
  }, 300);
}

// Rotate a face with animation
function rotateFace(face, direction, isDouble) {
  const rotations = isDouble ? 2 : 1;

  for (let i = 0; i < rotations; i++) {
    const newFace = [...cubeState[face]];
    if (direction === 1) {
      // Clockwise rotation
      newFace[0] = cubeState[face][6];
      newFace[1] = cubeState[face][3];
      newFace[2] = cubeState[face][0];
      newFace[3] = cubeState[face][7];
      newFace[5] = cubeState[face][1];
      newFace[6] = cubeState[face][8];
      newFace[7] = cubeState[face][5];
      newFace[8] = cubeState[face][2];
    } else {
      // Counter-clockwise rotation
      newFace[0] = cubeState[face][2];
      newFace[1] = cubeState[face][5];
      newFace[2] = cubeState[face][8];
      newFace[3] = cubeState[face][1];
      newFace[5] = cubeState[face][7];
      newFace[6] = cubeState[face][0];
      newFace[7] = cubeState[face][3];
      newFace[8] = cubeState[face][6];
    }
    cubeState[face] = newFace;
  }
}

// Rotate adjacent edges (more complete implementation)
function rotateAdjacentEdges(face, direction, isDouble) {
  // This is a more complete implementation that handles all adjacent edges
  switch(face) {
    case 'front':
      // Rotate up/down/left/right edges
      if (direction === 1) {
        // Clockwise
        const tempUp = [...cubeState.up].slice(6, 9);
        cubeState.up[6] = cubeState.left[8];
        cubeState.up[7] = cubeState.left[5];
        cubeState.up[8] = cubeState.left[2];

        cubeState.left[2] = cubeState.down[0];
        cubeState.left[5] = cubeState.down[1];
        cubeState.left[8] = cubeState.down[2];

        cubeState.down[0] = cubeState.right[6];
        cubeState.down[1] = cubeState.right[3];
        cubeState.down[2] = cubeState.right[0];

        cubeState.right[0] = tempUp[0];
        cubeState.right[3] = tempUp[1];
        cubeState.right[6] = tempUp[2];
      } else {
        // Counter-clockwise
        const tempUp = [...cubeState.up].slice(6, 9);
        cubeState.up[6] = cubeState.right[0];
        cubeState.up[7] = cubeState.right[3];
        cubeState.up[8] = cubeState.right[6];

        cubeState.right[0] = cubeState.down[2];
        cubeState.right[3] = cubeState.down[1];
        cubeState.right[6] = cubeState.down[0];

        cubeState.down[0] = cubeState.left[2];
        cubeState.down[1] = cubeState.left[5];
        cubeState.down[2] = cubeState.left[8];

        cubeState.left[2] = tempUp[2];
        cubeState.left[5] = tempUp[1];
        cubeState.left[8] = tempUp[0];
      }
      break;
      
    case 'back':
      // Rotate up/down/left/right edges
      if (direction === 1) {
        // Clockwise (from back view)
        const tempUp = [...cubeState.up].slice(0, 3);
        cubeState.up[0] = cubeState.right[2];
        cubeState.up[1] = cubeState.right[5];
        cubeState.up[2] = cubeState.right[8];

        cubeState.right[2] = cubeState.down[8];
        cubeState.right[5] = cubeState.down[7];
        cubeState.right[8] = cubeState.down[6];

        cubeState.down[6] = cubeState.left[0];
        cubeState.down[7] = cubeState.left[3];
        cubeState.down[8] = cubeState.left[6];

        cubeState.left[0] = tempUp[2];
        cubeState.left[3] = tempUp[1];
        cubeState.left[6] = tempUp[0];
      } else {
        // Counter-clockwise (from back view)
        const tempUp = [...cubeState.up].slice(0, 3);
        cubeState.up[0] = cubeState.left[6];
        cubeState.up[1] = cubeState.left[3];
        cubeState.up[2] = cubeState.left[0];

        cubeState.left[0] = cubeState.down[6];
        cubeState.left[3] = cubeState.down[7];
        cubeState.left[6] = cubeState.down[8];

        cubeState.down[6] = cubeState.right[8];
        cubeState.down[7] = cubeState.right[5];
        cubeState.down[8] = cubeState.right[2];

        cubeState.right[2] = tempUp[0];
        cubeState.right[5] = tempUp[1];
        cubeState.right[8] = tempUp[2];
      }
      break;
      
    case 'left':
      // Rotate up/front/down/back edges
      if (direction === 1) {
        // Clockwise
        const tempUp = [cubeState.up[0], cubeState.up[3], cubeState.up[6]];
        cubeState.up[0] = cubeState.back[8];
        cubeState.up[3] = cubeState.back[5];
        cubeState.up[6] = cubeState.back[2];

        cubeState.back[2] = cubeState.down[6];
        cubeState.back[5] = cubeState.down[3];
        cubeState.back[8] = cubeState.down[0];

        cubeState.down[0] = cubeState.front[0];
        cubeState.down[3] = cubeState.front[3];
        cubeState.down[6] = cubeState.front[6];

        cubeState.front[0] = tempUp[0];
        cubeState.front[3] = tempUp[1];
        cubeState.front[6] = tempUp[2];
      } else {
        // Counter-clockwise
        const tempUp = [cubeState.up[0], cubeState.up[3], cubeState.up[6]];
        cubeState.up[0] = cubeState.front[0];
        cubeState.up[3] = cubeState.front[3];
        cubeState.up[6] = cubeState.front[6];

        cubeState.front[0] = cubeState.down[0];
        cubeState.front[3] = cubeState.down[3];
        cubeState.front[6] = cubeState.down[6];

        cubeState.down[0] = cubeState.back[8];
        cubeState.down[3] = cubeState.back[5];
        cubeState.down[6] = cubeState.back[2];

        cubeState.back[2] = tempUp[2];
        cubeState.back[5] = tempUp[1];
        cubeState.back[8] = tempUp[0];
      }
      break;
      
    case 'right':
      // Rotate up/front/down/back edges
      if (direction === 1) {
        // Clockwise
        const tempUp = [cubeState.up[2], cubeState.up[5], cubeState.up[8]];
        cubeState.up[2] = cubeState.front[2];
        cubeState.up[5] = cubeState.front[5];
        cubeState.up[8] = cubeState.front[8];

        cubeState.front[2] = cubeState.down[2];
        cubeState.front[5] = cubeState.down[5];
        cubeState.front[8] = cubeState.down[8];

        cubeState.down[2] = cubeState.back[6];
        cubeState.down[5] = cubeState.back[3];
        cubeState.down[8] = cubeState.back[0];

        cubeState.back[0] = tempUp[2];
        cubeState.back[3] = tempUp[1];
        cubeState.back[6] = tempUp[0];
      } else {
        // Counter-clockwise
        const tempUp = [cubeState.up[2], cubeState.up[5], cubeState.up[8]];
        cubeState.up[2] = cubeState.back[6];
        cubeState.up[5] = cubeState.back[3];
        cubeState.up[8] = cubeState.back[0];

        cubeState.back[0] = cubeState.down[8];
        cubeState.back[3] = cubeState.down[5];
        cubeState.back[6] = cubeState.down[2];

        cubeState.down[2] = cubeState.front[2];
        cubeState.down[5] = cubeState.front[5];
        cubeState.down[8] = cubeState.front[8];

        cubeState.front[2] = tempUp[0];
        cubeState.front[5] = tempUp[1];
        cubeState.front[8] = tempUp[2];
      }
      break;
      
    case 'up':
      // Rotate front/right/back/left edges
      if (direction === 1) {
        // Clockwise
        const tempFront = [...cubeState.front].slice(0, 3);
        cubeState.front[0] = cubeState.right[0];
        cubeState.front[1] = cubeState.right[1];
        cubeState.front[2] = cubeState.right[2];

        cubeState.right[0] = cubeState.back[0];
        cubeState.right[1] = cubeState.back[1];
        cubeState.right[2] = cubeState.back[2];

        cubeState.back[0] = cubeState.left[0];
        cubeState.back[1] = cubeState.left[1];
        cubeState.back[2] = cubeState.left[2];

        cubeState.left[0] = tempFront[0];
        cubeState.left[1] = tempFront[1];
        cubeState.left[2] = tempFront[2];
      } else {
        // Counter-clockwise
        const tempFront = [...cubeState.front].slice(0, 3);
        cubeState.front[0] = cubeState.left[0];
        cubeState.front[1] = cubeState.left[1];
        cubeState.front[2] = cubeState.left[2];

        cubeState.left[0] = cubeState.back[0];
        cubeState.left[1] = cubeState.back[1];
        cubeState.left[2] = cubeState.back[2];

        cubeState.back[0] = cubeState.right[0];
        cubeState.back[1] = cubeState.right[1];
        cubeState.back[2] = cubeState.right[2];

        cubeState.right[0] = tempFront[0];
        cubeState.right[1] = tempFront[1];
        cubeState.right[2] = tempFront[2];
      }
      break;
      
    case 'down':
      // Rotate front/right/back/left edges
      if (direction === 1) {
        // Clockwise
        const tempFront = [...cubeState.front].slice(6, 9);
        cubeState.front[6] = cubeState.left[6];
        cubeState.front[7] = cubeState.left[7];
        cubeState.front[8] = cubeState.left[8];

        cubeState.left[6] = cubeState.back[6];
        cubeState.left[7] = cubeState.back[7];
        cubeState.left[8] = cubeState.back[8];

        cubeState.back[6] = cubeState.right[6];
        cubeState.back[7] = cubeState.right[7];
        cubeState.back[8] = cubeState.right[8];

        cubeState.right[6] = tempFront[0];
        cubeState.right[7] = tempFront[1];
        cubeState.right[8] = tempFront[2];
      } else {
        // Counter-clockwise
        const tempFront = [...cubeState.front].slice(6, 9);
        cubeState.front[6] = cubeState.right[6];
        cubeState.front[7] = cubeState.right[7];
        cubeState.front[8] = cubeState.right[8];

        cubeState.right[6] = cubeState.back[6];
        cubeState.right[7] = cubeState.back[7];
        cubeState.right[8] = cubeState.back[8];

        cubeState.back[6] = cubeState.left[6];
        cubeState.back[7] = cubeState.left[7];
        cubeState.back[8] = cubeState.left[8];

        cubeState.left[6] = tempFront[0];
        cubeState.left[7] = tempFront[1];
        cubeState.left[8] = tempFront[2];
      }
      break;
  }

  if (isDouble) {
    rotateAdjacentEdges(face, direction, false); // Apply twice for double moves
  }
}

// Solve the cube using enhanced AI simulation
function solveCube() {
  if (state.isPlayingSolution) return;

  document.getElementById('solution-container').style.display = 'block';
  const solutionSteps = document.getElementById('solution-steps');
  solutionSteps.innerHTML = '';

  // Show AI thinking indicator
  document.getElementById('ai-thinking').style.display = 'block';
  state.solveStartTime = Date.now();

  // Simulate AI thinking time based on cube complexity
  const thinkingTime = calculateThinkingTime();

  setTimeout(() => {
    document.getElementById('ai-thinking').style.display = 'none';

    // Generate a realistic solution based on current state
    state.solutionMoves = generateEnhancedAISolution();
    state.currentStep = 0;

    // Display solution steps
    state.solutionMoves.forEach((move, index) => {
      const step = document.createElement('div');
      step.className = 'step';
      step.dataset.index = index;

      const stepNum = document.createElement('div');
      stepNum.className = 'step-number';
      stepNum.textContent = index + 1;

      const stepContent = document.createElement('div');
      stepContent.innerHTML = `
        <span class="step-move">${move}</span>
        <span class="step-desc">${getMoveDescription(move)}</span>
      `;

      step.appendChild(stepNum);
      step.appendChild(stepContent);
      solutionSteps.appendChild(step);
    });

    document.getElementById('move-count').textContent = `(${state.solutionMoves.length} moves)`;
    highlightCurrentStep();

    // Update solve time
    const solveTime = ((Date.now() - state.solveStartTime) / 1000).toFixed(2);
    document.getElementById('time-display').textContent = `${solveTime}s`;
  }, thinkingTime);
}

// Calculate AI thinking time based on cube complexity
function calculateThinkingTime() {
  let complexity = 0;

  // Check how many pieces are already solved
  if (cubeState.front[4] !== 'white') complexity += 10;
  if (cubeState.up[4] !== 'red') complexity += 10;

  // Check edges
  if (cubeState.front[1] !== 'white' || cubeState.up[7] !== 'red') complexity += 5;
  if (cubeState.front[3] !== 'white' || cubeState.left[5] !== 'green') complexity += 5;
  if (cubeState.front[5] !== 'white' || cubeState.right[3] !== 'blue') complexity += 5;
  if (cubeState.front[7] !== 'white' || cubeState.down[1] !== 'orange') complexity += 5;

  // Check corners
  if (cubeState.front[0] !== 'white' || cubeState.up[6] !== 'red' || cubeState.left[2] !== 'green') complexity += 8;
  if (cubeState.front[2] !== 'white' || cubeState.up[8] !== 'red' || cubeState.right[0] !== 'blue') complexity += 8;
  if (cubeState.front[6] !== 'white' || cubeState.down[0] !== 'orange' || cubeState.left[8] !== 'green') complexity += 8;
  if (cubeState.front[8] !== 'white' || cubeState.down[2] !== 'orange' || cubeState.right[6] !== 'blue') complexity += 8;

  // Random variation to make it feel more realistic
  complexity += Math.random() * 500;

  // Clamp between 500ms and 3000ms
  return Math.min(Math.max(500, complexity), 3000);
}

// Generate enhanced AI solution based on cube state
function generateEnhancedAISolution() {
  // This is a more complete simulated version that follows CFOP method steps
  
  // Check current state to determine where to start
  const solvedPieces = countSolvedPieces();
  let solution = [];
  
  // Cross solution
  if (solvedPieces < 5) {
    solution = solveCross();
  }
  // First layer corners
  else if (solvedPieces < 9) {
    solution = solveFirstLayer();
  }
  // Second layer edges
  else if (solvedPieces < 17) {
    solution = solveSecondLayer();
  }
  // OLL (Orient Last Layer)
  else if (solvedPieces < 21) {
    solution = solveOLL();
  }
  // PLL (Permute Last Layer)
  else {
    solution = solvePLL();
  }

  // Add some random efficiency
  if (Math.random() > 0.7) {
    solution = optimizeSolution(solution);
  }

  return solution;
}

// Solve the white cross (simplified)
function solveCross() {
  const moves = [];
  
  // Solve each edge one by one (simplified)
  if (cubeState.front[1] !== 'white' || cubeState.up[7] !== 'red') {
    moves.push('F', 'U', 'R', 'U\'', 'R\'', 'F\'');
  }
  if (cubeState.front[3] !== 'white' || cubeState.left[5] !== 'green') {
    moves.push('L', 'U', 'F', 'U\'', 'F\'', 'L\'');
  }
  if (cubeState.front[5] !== 'white' || cubeState.right[3] !== 'blue') {
    moves.push('R\'', 'U\'', 'F\'', 'U', 'F', 'R');
  }
  if (cubeState.front[7] !== 'white' || cubeState.down[1] !== 'orange') {
    moves.push('D', 'F', 'D\'');
  }
  
  return moves.length > 0 ? moves : ['U']; // Default move if cross is already solved
}

// Solve first layer corners (simplified)
function solveFirstLayer() {
  const moves = [];
  
  // Solve each corner one by one (simplified)
  if (cubeState.front[0] !== 'white' || cubeState.up[6] !== 'red' || cubeState.left[2] !== 'green') {
    moves.push('U\'', 'L\'', 'U', 'L', 'U', 'F', 'U\'', 'F\'');
  }
  if (cubeState.front[2] !== 'white' || cubeState.up[8] !== 'red' || cubeState.right[0] !== 'blue') {
    moves.push('U', 'R', 'U\'', 'R\'', 'U\'', 'F\'', 'U', 'F');
  }
  if (cubeState.front[6] !== 'white' || cubeState.down[0] !== 'orange' || cubeState.left[8] !== 'green') {
    moves.push('L', 'D', 'L\'', 'D\'');
  }
  if (cubeState.front[8] !== 'white' || cubeState.down[2] !== 'orange' || cubeState.right[6] !== 'blue') {
    moves.push('R\'', 'D\'', 'R', 'D');
  }
  
  return moves.length > 0 ? moves : ['U']; // Default move if first layer is already solved
}

// Solve second layer edges (simplified)
function solveSecondLayer() {
  const moves = [];
  
  // Solve each edge one by one (simplified)
  if (cubeState.right[1] !== 'blue' || cubeState.up[5] !== 'red') {
    moves.push('U', 'R', 'U\'', 'R\'', 'U\'', 'F\'', 'U', 'F');
  }
  if (cubeState.left[1] !== 'green' || cubeState.up[3] !== 'red') {
    moves.push('U\'', 'L\'', 'U', 'L', 'U', 'F', 'U\'', 'F\'');
  }
  if (cubeState.right[7] !== 'blue' || cubeState.down[5] !== 'orange') {
    moves.push('D\'', 'R\'', 'D', 'R', 'D', 'F', 'D\'', 'F\'');
  }
  if (cubeState.left[7] !== 'green' || cubeState.down[3] !== 'orange') {
    moves.push('D', 'L', 'D\'', 'L\'', 'D\'', 'F\'', 'D', 'F');
  }
  
  return moves.length > 0 ? moves : ['U']; // Default move if second layer is already solved
}

// Solve OLL (Orient Last Layer - simplified)
function solveOLL() {
  // Check for different OLL cases (simplified)
  const moves = [];
  
  // Check if all top face is yellow (already solved)
  const topFace = cubeState.up;
  const allYellow = topFace.every(color => color === 'yellow');
  
  if (!allYellow) {
    // Simple OLL algorithm (just one case for demo)
    moves.push('F', 'R', 'U', 'R\'', 'U\'', 'F\'');
  }
  
  return moves.length > 0 ? moves : ['U']; // Default move if OLL is already solved
}

// Solve PLL (Permute Last Layer - simplified)
function solvePLL() {
  // Check for different PLL cases (simplified)
  const moves = [];
  
  // Check if all edges are correct
  if (cubeState.up[1] !== 'yellow' || cubeState.up[3] !== 'yellow' || 
      cubeState.up[5] !== 'yellow' || cubeState.up[7] !== 'yellow') {
    // Simple PLL algorithm (just one case for demo)
    moves.push('R', 'U', 'R\'', 'U\'', 'R\'', 'F', 'R2', 'U\'', 'R\'', 'U\'', 'R', 'U', 'R\'', 'F\'');
  }
  
  return moves.length > 0 ? moves : []; // No moves if already solved
}

// Count solved pieces to determine progress
function countSolvedPieces() {
  let count = 0;

  // Center pieces
  if (cubeState.front[4] === 'white') count++;
  if (cubeState.up[4] === 'red') count++;
  if (cubeState.back[4] === 'yellow') count++;
  if (cubeState.down[4] === 'orange') count++;
  if (cubeState.left[4] === 'green') count++;
  if (cubeState.right[4] === 'blue') count++;

  // Cross pieces
  if (cubeState.front[1] === 'white' && cubeState.up[7] === 'red') count++;
  if (cubeState.front[3] === 'white' && cubeState.left[5] === 'green') count++;
  if (cubeState.front[5] === 'white' && cubeState.right[3] === 'blue') count++;
  if (cubeState.front[7] === 'white' && cubeState.down[1] === 'orange') count++;

  // First layer corners
  if (cubeState.front[0] === 'white' && cubeState.up[6] === 'red' && cubeState.left[2] === 'green') count++;
  if (cubeState.front[2] === 'white' && cubeState.up[8] === 'red' && cubeState.right[0] === 'blue') count++;
  if (cubeState.front[6] === 'white' && cubeState.down[0] === 'orange' && cubeState.left[8] === 'green') count++;
  if (cubeState.front[8] === 'white' && cubeState.down[2] === 'orange' && cubeState.right[6] === 'blue') count++;

  // Second layer edges
  if (cubeState.right[1] === 'blue' && cubeState.up[5] === 'red') count++;
  if (cubeState.left[1] === 'green' && cubeState.up[3] === 'red') count++;
  if (cubeState.right[7] === 'blue' && cubeState.down[5] === 'orange') count++;
  if (cubeState.left[7] === 'green' && cubeState.down[3] === 'orange') count++;

  // Last layer edges
  if (cubeState.up[1] === 'yellow' && cubeState.back[1] === 'yellow') count++;
  if (cubeState.up[3] === 'yellow' && cubeState.left[1] === 'green') count++;
  if (cubeState.up[5] === 'yellow' && cubeState.right[1] === 'blue') count++;
  if (cubeState.up[7] === 'yellow' && cubeState.front[1] === 'white') count++;

  // Last layer corners
  if (cubeState.up[0] === 'yellow' && cubeState.left[0] === 'green' && cubeState.back[2] === 'yellow') count++;
  if (cubeState.up[2] === 'yellow' && cubeState.right[2] === 'blue' && cubeState.back[0] === 'yellow') count++;
  if (cubeState.up[6] === 'yellow' && cubeState.left[2] === 'green' && cubeState.front[0] === 'white') count++;
  if (cubeState.up[8] === 'yellow' && cubeState.right[0] === 'blue' && cubeState.front[2] === 'white') count++;

  return count;
}

// Simulate solution optimization
function optimizeSolution(solution) {
  // Combine moves where possible (e.g., "U U" becomes "U2")
  const optimized = [];
  let i = 0;

  while (i < solution.length) {
    if (i < solution.length - 1 && solution[i].replace(/['2]/g, '') === solution[i+1].replace(/['2]/g, '')) {
      // Same face consecutive moves
      const face = solution[i].replace(/['2]/g, '');
      const move1 = solution[i].includes('\'') ? -1 : 1;
      const move2 = solution[i+1].includes('\'') ? -1 : 1;

      if (move1 === move2) {
        optimized.push(`${face}2`);
        i += 2;
      } else {
        // Opposite moves cancel out
        i += 2;
      }
    } else {
      optimized.push(solution[i]);
      i++;
    }
  }

  return optimized.length > 0 ? optimized : solution;
}

// Get description for a move
function getMoveDescription(move) {
  const moveMap = {
    'F': 'Front face clockwise',
    'F\'': 'Front face counter-clockwise',
    'F2': 'Front face 180°',
    'B': 'Back face clockwise',
    'B\'': 'Back face counter-clockwise',
    'B2': 'Back face 180°',
    'L': 'Left face clockwise',
    'L\'': 'Left face counter-clockwise',
    'L2': 'Left face 180°',
    'R': 'Right face clockwise',
    'R\'': 'Right face counter-clockwise',
    'R2': 'Right face 180°',
    'U': 'Upper face clockwise',
    'U\'': 'Upper face counter-clockwise',
    'U2': 'Upper face 180°',
    'D': 'Down face clockwise',
    'D\'': 'Down face counter-clockwise',
    'D2': 'Down face 180°'
  };
  return moveMap[move] || move;
}

// Highlight current step in solution
function highlightCurrentStep() {
  document.querySelectorAll('.step').forEach(step => {
    step.classList.remove('active');
  });

  if (state.currentStep >= 0 && state.currentStep < state.solutionMoves.length) {
    const activeStep = document.querySelector(`.step[data-index="${state.currentStep}"]`);
    if (activeStep) {
      activeStep.classList.add('active');
      activeStep.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }
}

// Play the solution step by step with animations
function playSolution() {
  if (state.isPlayingSolution || state.solutionMoves.length === 0) return;

  state.isPlayingSolution = true;
  state.currentStep = 0;
  document.getElementById('play-solution').style.display = 'none';
  document.getElementById('stop-solution').style.display = 'flex';
  document.getElementById('play-solution').classList.add('pulse');

  playNextMove();
}

function playNextMove() {
  if (!state.isPlayingSolution || state.currentStep >= state.solutionMoves.length) {
    stopSolutionPlayback();
    
    // Check if cube is solved
    if (isCubeSolved()) {
      showCelebration();
    }
    return;
  }

  const move = state.solutionMoves[state.currentStep];
  applyMove(move);

  // Add visual feedback for the move
  const cube = document.getElementById('cube');
  cube.style.setProperty('--rotate-x', `${Math.random() * 20 - 10}deg`);
  cube.style.setProperty('--rotate-y', `${Math.random() * 20 - 10}deg`);
  cube.classList.add('rotate-animation');

  setTimeout(() => {
    cube.classList.remove('rotate-animation');
  }, 600);

  // Highlight current step
  highlightCurrentStep();

  state.currentStep++;

  // Continue to next move after delay
  setTimeout(playNextMove, 800);
}

function stopSolutionPlayback() {
  state.isPlayingSolution = false;
  document.getElementById('play-solution').style.display = 'flex';
  document.getElementById('stop-solution').style.display = 'none';
  document.getElementById('play-solution').classList.remove('pulse');
}

// Check if cube is solved
function isCubeSolved() {
  // Check all faces have uniform color (except center in odd cubes)
  const faces = ['front', 'back', 'left', 'right', 'up', 'down'];
  
  for (const face of faces) {
    const centerColor = cubeState[face][4];
    for (let i = 0; i < 9; i++) {
      if (i === 4) continue; // Skip center
      if (cubeState[face][i] !== centerColor) return false;
    }
  }
  return true;
}

// Show celebration effects when cube is solved
function showCelebration() {
  // Confetti effect
  for (let i = 0; i < 100; i++) {
    createConfetti();
  }

  // Pulse animation
  const cube = document.getElementById('cube');
  cube.classList.add('pulse');

  // Show message
  const indicator = document.getElementById('face-indicator');
  indicator.textContent = "Cube Solved! 🎉";
  indicator.style.color = '#34c759';

  setTimeout(() => {
    cube.classList.remove('pulse');
    indicator.style.color = '';
  }, 3000);
}

// Create confetti particle
function createConfetti() {
  const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
  const confetti = document.createElement('div');
  confetti.className = 'confetti';
  confetti.style.left = `${Math.random() * 100}vw`;
  confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
  confetti.style.width = `${Math.random() * 10 + 5}px`;
  confetti.style.height = `${Math.random() * 10 + 5}px`;
  document.body.appendChild(confetti);

  setTimeout(() => {
    confetti.remove();
  }, 3000);
}

// Reset cube to solved state
function resetCube() {
  if (state.isPlayingSolution) return;

  cubeState.front = Array(9).fill('white');
  cubeState.back = Array(9).fill('yellow');
  cubeState.left = Array(9).fill('green');
  cubeState.right = Array(9).fill('blue');
  cubeState.up = Array(9).fill('red');
  cubeState.down = Array(9).fill('orange');
  
  // Reset piece tracking
  cubeState.pieces.edges = [
    { position: 'UF', colors: ['white', 'red'], orientation: 0 },
    { position: 'UR', colors: ['white', 'blue'], orientation: 0 },
    { position: 'UB', colors: ['white', 'yellow'], orientation: 0 },
    { position: 'UL', colors: ['white', 'green'], orientation: 0 },
    { position: 'DF', colors: ['white', 'orange'], orientation: 0 },
    { position: 'DR', colors: ['white', 'blue'], orientation: 0 },
    { position: 'DB', colors: ['white', 'yellow'], orientation: 0 },
    { position: 'DL', colors: ['white', 'green'], orientation: 0 },
    { position: 'FR', colors: ['white', 'blue'], orientation: 0 },
    { position: 'FL', colors: ['white', 'green'], orientation: 0 },
    { position: 'BR', colors: ['yellow', 'blue'], orientation: 0 },
    { position: 'BL', colors: ['yellow', 'green'], orientation: 0 }
  ];
  
  cubeState.pieces.corners = [
    { position: 'UFR', colors: ['white', 'red', 'blue'], orientation: 0 },
    { position: 'URB', colors: ['white', 'red', 'blue'], orientation: 0 },
    { position: 'UBL', colors: ['white', 'red', 'green'], orientation: 0 },
    { position: 'ULF', colors: ['white', 'red', 'green'], orientation: 0 },
    { position: 'DRF', colors: ['white', 'orange', 'blue'], orientation: 0 },
    { position: 'DFL', colors: ['white', 'orange', 'green'], orientation: 0 },
    { position: 'DLB', colors: ['white', 'orange', 'green'], orientation: 0 },
    { position: 'DBR', colors: ['white', 'orange', 'blue'], orientation: 0 }
  ];

  initCube();
  document.getElementById('solution-container').style.display = 'none';
  state.moveHistory = [];
  state.totalMoves = 0;
  updateMoveCounter();
  updateMoveHistory();
  updateDifficultyEstimate();
}

// Timer functions
function startTimer() {
  if (state.isPlayingSolution) return;

  if (!state.timerRunning) {
    state.startTime = Date.now() - state.elapsedTime;
    state.timerInterval = setInterval(updateTimer, 10);
    state.timerRunning = true;
    document.getElementById('timer-btn').textContent = '⏹️ Stop Timer';
    
    // Hide inspection timer if visible
    if (state.isInspecting) {
      clearInterval(state.inspectionInterval);
      document.getElementById('inspection-mode').style.display = 'none';
      state.isInspecting = false;
    }
  } else {
    stopTimer();
    document.getElementById('timer-btn').textContent = '⏱️ Start Timer';
  }
}

function stopTimer() {
  clearInterval(state.timerInterval);
  state.timerRunning = false;
}

function resetTimer() {
  stopTimer();
  state.elapsedTime = 0;
  document.getElementById('timer').textContent = '00:00.00';
}

function updateTimer() {
  const currentTime = Date.now();
  state.elapsedTime = currentTime - state.startTime;

  const minutes = Math.floor(state.elapsedTime / 60000);
  const seconds = Math.floor((state.elapsedTime % 60000) / 1000);
  const milliseconds = Math.floor((state.elapsedTime % 1000) / 10);

  document.getElementById('timer').textContent =
    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
}

// Update cube size based on slider
function updateCubeSize() {
  state.cubeSize = document.getElementById('size-slider').value;
  document.documentElement.style.setProperty('--cube-size', `${state.cubeSize}px`);
  document.getElementById('size-value').textContent = state.cubeSize;
}

// Update move counter display
function updateMoveCounter() {
  document.getElementById('move-count-display').textContent = state.totalMoves;
}

// Update move history display
function updateMoveHistory() {
  const historyElement = document.getElementById('move-history');
  historyElement.innerHTML = '';

  state.moveHistory.forEach(move => {
    const tag = document.createElement('span');
    tag.className = 'move-tag';
    tag.textContent = move;
    historyElement.appendChild(tag);
  });
}

// Update difficulty estimate
function updateDifficultyEstimate() {
  const difficultyElement = document.getElementById('difficulty-display');
  const solvedPieces = countSolvedPieces();

  if (solvedPieces < 5) {
    difficultyElement.textContent = "Hard";
    difficultyElement.style.color = '#ff3b30';
  } else if (solvedPieces < 9) {
    difficultyElement.textContent = "Medium";
    difficultyElement.style.color = '#ff9500';
  } else if (solvedPieces < 17) {
    difficultyElement.textContent = "Easy";
    difficultyElement.style.color = '#34c759';
  } else {
    difficultyElement.textContent = "Solved";
    difficultyElement.style.color = '#0071e3';
  }
}

// Event listeners for cube rotation
function setupDragRotation() {
  const scene = document.getElementById('cube-scene');

  // Mouse events
  scene.addEventListener('mousedown', (e) => {
    if (state.isPlayingSolution) return;
    state.isDragging = true;
    state.startX = e.clientX;
    startY = e.clientY;
    state.prevRotateX = state.rotateX;
    state.prevRotateY = state.rotateY;
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!state.isDragging || state.isPlayingSolution) return;
    const dx = e.clientX - state.startX;
    const dy = e.clientY - state.startY;

    state.rotateY = state.prevRotateY + dx * 0.5;
    state.rotateX = state.prevRotateX - dy * 0.5;

    updateCubeRotation();
    e.preventDefault();
  });

  document.addEventListener('mouseup', () => {
    state.isDragging = false;
  });

  // Touch events
  scene.addEventListener('touchstart', (e) => {
    if (state.isPlayingSolution) return;
    state.isDragging = true;
    state.startX = e.touches[0].clientX;
    state.startY = e.touches[0].clientY;
    state.prevRotateX = state.rotateX;
    state.prevRotateY = state.rotateY;
    e.preventDefault();
  });

  document.addEventListener('touchmove', (e) => {
    if (!state.isDragging || state.isPlayingSolution) return;
    const dx = e.touches[0].clientX - state.startX;
    const dy = e.touches[0].clientY - state.startY;

    state.rotateY = state.prevRotateY + dx * 0.5;
    state.rotateX = state.prevRotateX - dy * 0.5;

    updateCubeRotation();
    e.preventDefault();
  });

  document.addEventListener('touchend', () => {
    state.isDragging = false;
  });
}

// Initialize the app
document.addEventListener('DOMContentLoaded', () => {
  initCube();
  setupDragRotation();

  // Color picker
  document.querySelectorAll('.color-option').forEach(option => {
    option.addEventListener('click', () => {
      if (state.isPlayingSolution) return;
      document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
      option.classList.add('selected');
      state.currentColor = option.dataset.color;
    });
  });

  // Face selection
  document.getElementById('front-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'front';
    state.rotateX = -20;
    state.rotateY = -20;
    updateCubeRotation();
  });

  document.getElementById('back-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'back';
    state.rotateX = -20;
    state.rotateY = 160;
    updateCubeRotation();
  });

  document.getElementById('left-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'left';
    state.rotateX = -20;
    state.rotateY = -110;
    updateCubeRotation();
  });

  document.getElementById('right-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'right';
    state.rotateX = -20;
    state.rotateY = 70;
    updateCubeRotation();
  });

  document.getElementById('up-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'up';
    state.rotateX = -110;
    state.rotateY = -20;
    updateCubeRotation();
  });

  document.getElementById('down-btn').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    state.currentFace = 'down';
    state.rotateX = 70;
    state.rotateY = -20;
    updateCubeRotation();
  });

  // Manual rotation buttons
  document.getElementById('rotate-front-btn').addEventListener('click', () => applyMove('F', true));
  document.getElementById('rotate-back-btn').addEventListener('click', () => applyMove('B', true));
  document.getElementById('rotate-left-btn').addEventListener('click', () => applyMove('L', true));
  document.getElementById('rotate-right-btn').addEventListener('click', () => applyMove('R', true));
  document.getElementById('rotate-up-btn').addEventListener('click', () => applyMove('U', true));
  document.getElementById('rotate-down-btn').addEventListener('click', () => applyMove('D', true));
  
  // Prime rotations
  document.getElementById('rotate-front-prime-btn').addEventListener('click', () => applyMove('F\'', true));
  document.getElementById('rotate-back-prime-btn').addEventListener('click', () => applyMove('B\'', true));
  document.getElementById('rotate-left-prime-btn').addEventListener('click', () => applyMove('L\'', true));
  document.getElementById('rotate-right-prime-btn').addEventListener('click', () => applyMove('R\'', true));
  document.getElementById('rotate-up-prime-btn').addEventListener('click', () => applyMove('U\'', true));
  document.getElementById('rotate-down-prime-btn').addEventListener('click', () => applyMove('D\'', true));
  
  // Double rotations
  document.getElementById('rotate-front-double-btn').addEventListener('click', () => applyMove('F2', true));
  document.getElementById('rotate-back-double-btn').addEventListener('click', () => applyMove('B2', true));
  document.getElementById('rotate-left-double-btn').addEventListener('click', () => applyMove('L2', true));
  document.getElementById('rotate-right-double-btn').addEventListener('click', () => applyMove('R2', true));
  document.getElementById('rotate-up-double-btn').addEventListener('click', () => applyMove('U2', true));
  document.getElementById('rotate-down-double-btn').addEventListener('click', () => applyMove('D2', true));

  // Cube view rotation buttons
  document.getElementById('rotate-left').addEventListener('click', () => {
    state.rotateY -= 30;
    updateCubeRotation();
  });

  document.getElementById('rotate-right').addEventListener('click', () => {
    state.rotateY += 30;
    updateCubeRotation();
  });

  document.getElementById('rotate-up').addEventListener('click', () => {
    state.rotateX -= 30;
    updateCubeRotation();
  });

  document.getElementById('rotate-down').addEventListener('click', () => {
    state.rotateX += 30;
    updateCubeRotation();
  });

  document.getElementById('rotate-ccw').addEventListener('click', () => {
    state.rotateY -= 90;
    updateCubeRotation();
  });

  document.getElementById('rotate-cw').addEventListener('click', () => {
    state.rotateY += 90;
    updateCubeRotation();
  });

  // Buttons
  document.getElementById('scramble-btn').addEventListener('click', scrambleCube);
  document.getElementById('solve-btn').addEventListener('click', solveCube);
  document.getElementById('reset-btn').addEventListener('click', resetCube);
  document.getElementById('timer-btn').addEventListener('click', startTimer);

  // Solution navigation
  document.getElementById('prev-step').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    if (state.currentStep > 0) {
      state.currentStep--;
      highlightCurrentStep();
    }
  });

  document.getElementById('next-step').addEventListener('click', () => {
    if (state.isPlayingSolution) return;
    if (state.currentStep < state.solutionMoves.length - 1) {
      state.currentStep++;
      highlightCurrentStep();
    }
  });

  document.getElementById('play-solution').addEventListener('click', playSolution);
  document.getElementById('stop-solution').addEventListener('click', stopSolutionPlayback);

  // Size slider
  document.getElementById('size-slider').addEventListener('input', updateCubeSize);

  // Initial updates
  updateMoveCounter();
  updateDifficultyEstimate();
});
</script>
</body>
</html>
